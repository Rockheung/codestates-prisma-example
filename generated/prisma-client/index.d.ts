// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  deptEmp: (where?: DeptEmpWhereInput) => Promise<boolean>;
  deptManager: (where?: DeptManagerWhereInput) => Promise<boolean>;
  employee: (where?: EmployeeWhereInput) => Promise<boolean>;
  salary: (where?: SalaryWhereInput) => Promise<boolean>;
  title: (where?: TitleWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  department: (where: DepartmentWhereUniqueInput) => DepartmentNullablePromise;
  departments: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Department>;
  departmentsConnection: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DepartmentConnectionPromise;
  deptEmp: (where: DeptEmpWhereUniqueInput) => DeptEmpNullablePromise;
  deptEmps: (args?: {
    where?: DeptEmpWhereInput;
    orderBy?: DeptEmpOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DeptEmp>;
  deptEmpsConnection: (args?: {
    where?: DeptEmpWhereInput;
    orderBy?: DeptEmpOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DeptEmpConnectionPromise;
  deptManager: (
    where: DeptManagerWhereUniqueInput
  ) => DeptManagerNullablePromise;
  deptManagers: (args?: {
    where?: DeptManagerWhereInput;
    orderBy?: DeptManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DeptManager>;
  deptManagersConnection: (args?: {
    where?: DeptManagerWhereInput;
    orderBy?: DeptManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DeptManagerConnectionPromise;
  employee: (where: EmployeeWhereUniqueInput) => EmployeeNullablePromise;
  employees: (args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Employee>;
  employeesConnection: (args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmployeeConnectionPromise;
  salary: (where: SalaryWhereUniqueInput) => SalaryNullablePromise;
  salaries: (args?: {
    where?: SalaryWhereInput;
    orderBy?: SalaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Salary>;
  salariesConnection: (args?: {
    where?: SalaryWhereInput;
    orderBy?: SalaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SalaryConnectionPromise;
  title: (where: TitleWhereUniqueInput) => TitleNullablePromise;
  titles: (args?: {
    where?: TitleWhereInput;
    orderBy?: TitleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Title>;
  titlesConnection: (args?: {
    where?: TitleWhereInput;
    orderBy?: TitleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TitleConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDepartment: (data: DepartmentCreateInput) => DepartmentPromise;
  updateDepartment: (args: {
    data: DepartmentUpdateInput;
    where: DepartmentWhereUniqueInput;
  }) => DepartmentPromise;
  updateManyDepartments: (args: {
    data: DepartmentUpdateManyMutationInput;
    where?: DepartmentWhereInput;
  }) => BatchPayloadPromise;
  upsertDepartment: (args: {
    where: DepartmentWhereUniqueInput;
    create: DepartmentCreateInput;
    update: DepartmentUpdateInput;
  }) => DepartmentPromise;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayloadPromise;
  createDeptEmp: (data: DeptEmpCreateInput) => DeptEmpPromise;
  updateDeptEmp: (args: {
    data: DeptEmpUpdateInput;
    where: DeptEmpWhereUniqueInput;
  }) => DeptEmpPromise;
  updateManyDeptEmps: (args: {
    data: DeptEmpUpdateManyMutationInput;
    where?: DeptEmpWhereInput;
  }) => BatchPayloadPromise;
  upsertDeptEmp: (args: {
    where: DeptEmpWhereUniqueInput;
    create: DeptEmpCreateInput;
    update: DeptEmpUpdateInput;
  }) => DeptEmpPromise;
  deleteDeptEmp: (where: DeptEmpWhereUniqueInput) => DeptEmpPromise;
  deleteManyDeptEmps: (where?: DeptEmpWhereInput) => BatchPayloadPromise;
  createDeptManager: (data: DeptManagerCreateInput) => DeptManagerPromise;
  updateDeptManager: (args: {
    data: DeptManagerUpdateInput;
    where: DeptManagerWhereUniqueInput;
  }) => DeptManagerPromise;
  updateManyDeptManagers: (args: {
    data: DeptManagerUpdateManyMutationInput;
    where?: DeptManagerWhereInput;
  }) => BatchPayloadPromise;
  upsertDeptManager: (args: {
    where: DeptManagerWhereUniqueInput;
    create: DeptManagerCreateInput;
    update: DeptManagerUpdateInput;
  }) => DeptManagerPromise;
  deleteDeptManager: (where: DeptManagerWhereUniqueInput) => DeptManagerPromise;
  deleteManyDeptManagers: (
    where?: DeptManagerWhereInput
  ) => BatchPayloadPromise;
  createEmployee: (data: EmployeeCreateInput) => EmployeePromise;
  updateEmployee: (args: {
    data: EmployeeUpdateInput;
    where: EmployeeWhereUniqueInput;
  }) => EmployeePromise;
  updateManyEmployees: (args: {
    data: EmployeeUpdateManyMutationInput;
    where?: EmployeeWhereInput;
  }) => BatchPayloadPromise;
  upsertEmployee: (args: {
    where: EmployeeWhereUniqueInput;
    create: EmployeeCreateInput;
    update: EmployeeUpdateInput;
  }) => EmployeePromise;
  deleteEmployee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  deleteManyEmployees: (where?: EmployeeWhereInput) => BatchPayloadPromise;
  createSalary: (data: SalaryCreateInput) => SalaryPromise;
  updateSalary: (args: {
    data: SalaryUpdateInput;
    where: SalaryWhereUniqueInput;
  }) => SalaryPromise;
  updateManySalaries: (args: {
    data: SalaryUpdateManyMutationInput;
    where?: SalaryWhereInput;
  }) => BatchPayloadPromise;
  upsertSalary: (args: {
    where: SalaryWhereUniqueInput;
    create: SalaryCreateInput;
    update: SalaryUpdateInput;
  }) => SalaryPromise;
  deleteSalary: (where: SalaryWhereUniqueInput) => SalaryPromise;
  deleteManySalaries: (where?: SalaryWhereInput) => BatchPayloadPromise;
  createTitle: (data: TitleCreateInput) => TitlePromise;
  updateTitle: (args: {
    data: TitleUpdateInput;
    where: TitleWhereUniqueInput;
  }) => TitlePromise;
  updateManyTitles: (args: {
    data: TitleUpdateManyMutationInput;
    where?: TitleWhereInput;
  }) => BatchPayloadPromise;
  upsertTitle: (args: {
    where: TitleWhereUniqueInput;
    create: TitleCreateInput;
    update: TitleUpdateInput;
  }) => TitlePromise;
  deleteTitle: (where: TitleWhereUniqueInput) => TitlePromise;
  deleteManyTitles: (where?: TitleWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  department: (
    where?: DepartmentSubscriptionWhereInput
  ) => DepartmentSubscriptionPayloadSubscription;
  deptEmp: (
    where?: DeptEmpSubscriptionWhereInput
  ) => DeptEmpSubscriptionPayloadSubscription;
  deptManager: (
    where?: DeptManagerSubscriptionWhereInput
  ) => DeptManagerSubscriptionPayloadSubscription;
  employee: (
    where?: EmployeeSubscriptionWhereInput
  ) => EmployeeSubscriptionPayloadSubscription;
  salary: (
    where?: SalarySubscriptionWhereInput
  ) => SalarySubscriptionPayloadSubscription;
  title: (
    where?: TitleSubscriptionWhereInput
  ) => TitleSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type EmployeesGenderEnum = "F" | "M";

export type DeptEmpOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fromDate_ASC"
  | "fromDate_DESC"
  | "toDate_ASC"
  | "toDate_DESC";

export type DeptManagerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fromDate_ASC"
  | "fromDate_DESC"
  | "toDate_ASC"
  | "toDate_DESC";

export type SalaryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fromDate_ASC"
  | "fromDate_DESC"
  | "salary_ASC"
  | "salary_DESC"
  | "toDate_ASC"
  | "toDate_DESC";

export type TitleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fromDate_ASC"
  | "fromDate_DESC"
  | "title_ASC"
  | "title_DESC"
  | "toDate_ASC"
  | "toDate_DESC";

export type DepartmentOrderByInput =
  | "dept_no_ASC"
  | "dept_no_DESC"
  | "deptName_ASC"
  | "deptName_DESC";

export type EmployeeOrderByInput =
  | "emp_no_ASC"
  | "emp_no_DESC"
  | "birthDate_ASC"
  | "birthDate_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "hireDate_ASC"
  | "hireDate_DESC"
  | "lastName_ASC"
  | "lastName_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type DepartmentWhereUniqueInput = AtLeastOne<{
  dept_no: Maybe<ID_Input>;
  deptName?: Maybe<String>;
}>;

export interface DeptEmpWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  deptNo?: Maybe<DepartmentWhereInput>;
  empNo?: Maybe<EmployeeWhereInput>;
  fromDate?: Maybe<DateTimeInput>;
  fromDate_not?: Maybe<DateTimeInput>;
  fromDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_lt?: Maybe<DateTimeInput>;
  fromDate_lte?: Maybe<DateTimeInput>;
  fromDate_gt?: Maybe<DateTimeInput>;
  fromDate_gte?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
  toDate_not?: Maybe<DateTimeInput>;
  toDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_lt?: Maybe<DateTimeInput>;
  toDate_lte?: Maybe<DateTimeInput>;
  toDate_gt?: Maybe<DateTimeInput>;
  toDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DeptEmpWhereInput[] | DeptEmpWhereInput>;
  OR?: Maybe<DeptEmpWhereInput[] | DeptEmpWhereInput>;
  NOT?: Maybe<DeptEmpWhereInput[] | DeptEmpWhereInput>;
}

export interface DepartmentWhereInput {
  dept_no?: Maybe<ID_Input>;
  dept_no_not?: Maybe<ID_Input>;
  dept_no_in?: Maybe<ID_Input[] | ID_Input>;
  dept_no_not_in?: Maybe<ID_Input[] | ID_Input>;
  dept_no_lt?: Maybe<ID_Input>;
  dept_no_lte?: Maybe<ID_Input>;
  dept_no_gt?: Maybe<ID_Input>;
  dept_no_gte?: Maybe<ID_Input>;
  dept_no_contains?: Maybe<ID_Input>;
  dept_no_not_contains?: Maybe<ID_Input>;
  dept_no_starts_with?: Maybe<ID_Input>;
  dept_no_not_starts_with?: Maybe<ID_Input>;
  dept_no_ends_with?: Maybe<ID_Input>;
  dept_no_not_ends_with?: Maybe<ID_Input>;
  deptName?: Maybe<String>;
  deptName_not?: Maybe<String>;
  deptName_in?: Maybe<String[] | String>;
  deptName_not_in?: Maybe<String[] | String>;
  deptName_lt?: Maybe<String>;
  deptName_lte?: Maybe<String>;
  deptName_gt?: Maybe<String>;
  deptName_gte?: Maybe<String>;
  deptName_contains?: Maybe<String>;
  deptName_not_contains?: Maybe<String>;
  deptName_starts_with?: Maybe<String>;
  deptName_not_starts_with?: Maybe<String>;
  deptName_ends_with?: Maybe<String>;
  deptName_not_ends_with?: Maybe<String>;
  deptEmp_every?: Maybe<DeptEmpWhereInput>;
  deptEmp_some?: Maybe<DeptEmpWhereInput>;
  deptEmp_none?: Maybe<DeptEmpWhereInput>;
  deptManagers_every?: Maybe<DeptManagerWhereInput>;
  deptManagers_some?: Maybe<DeptManagerWhereInput>;
  deptManagers_none?: Maybe<DeptManagerWhereInput>;
  AND?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  OR?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  NOT?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
}

export interface DeptManagerWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  deptNo?: Maybe<DepartmentWhereInput>;
  empNo?: Maybe<EmployeeWhereInput>;
  fromDate?: Maybe<DateTimeInput>;
  fromDate_not?: Maybe<DateTimeInput>;
  fromDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_lt?: Maybe<DateTimeInput>;
  fromDate_lte?: Maybe<DateTimeInput>;
  fromDate_gt?: Maybe<DateTimeInput>;
  fromDate_gte?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
  toDate_not?: Maybe<DateTimeInput>;
  toDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_lt?: Maybe<DateTimeInput>;
  toDate_lte?: Maybe<DateTimeInput>;
  toDate_gt?: Maybe<DateTimeInput>;
  toDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DeptManagerWhereInput[] | DeptManagerWhereInput>;
  OR?: Maybe<DeptManagerWhereInput[] | DeptManagerWhereInput>;
  NOT?: Maybe<DeptManagerWhereInput[] | DeptManagerWhereInput>;
}

export interface EmployeeWhereInput {
  emp_no?: Maybe<Int>;
  emp_no_not?: Maybe<Int>;
  emp_no_in?: Maybe<Int[] | Int>;
  emp_no_not_in?: Maybe<Int[] | Int>;
  emp_no_lt?: Maybe<Int>;
  emp_no_lte?: Maybe<Int>;
  emp_no_gt?: Maybe<Int>;
  emp_no_gte?: Maybe<Int>;
  birthDate?: Maybe<DateTimeInput>;
  birthDate_not?: Maybe<DateTimeInput>;
  birthDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthDate_lt?: Maybe<DateTimeInput>;
  birthDate_lte?: Maybe<DateTimeInput>;
  birthDate_gt?: Maybe<DateTimeInput>;
  birthDate_gte?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  gender?: Maybe<EmployeesGenderEnum>;
  gender_not?: Maybe<EmployeesGenderEnum>;
  gender_in?: Maybe<EmployeesGenderEnum[] | EmployeesGenderEnum>;
  gender_not_in?: Maybe<EmployeesGenderEnum[] | EmployeesGenderEnum>;
  hireDate?: Maybe<DateTimeInput>;
  hireDate_not?: Maybe<DateTimeInput>;
  hireDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  hireDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  hireDate_lt?: Maybe<DateTimeInput>;
  hireDate_lte?: Maybe<DateTimeInput>;
  hireDate_gt?: Maybe<DateTimeInput>;
  hireDate_gte?: Maybe<DateTimeInput>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  deptEmp_every?: Maybe<DeptEmpWhereInput>;
  deptEmp_some?: Maybe<DeptEmpWhereInput>;
  deptEmp_none?: Maybe<DeptEmpWhereInput>;
  deptManagers_every?: Maybe<DeptManagerWhereInput>;
  deptManagers_some?: Maybe<DeptManagerWhereInput>;
  deptManagers_none?: Maybe<DeptManagerWhereInput>;
  salaries_every?: Maybe<SalaryWhereInput>;
  salaries_some?: Maybe<SalaryWhereInput>;
  salaries_none?: Maybe<SalaryWhereInput>;
  titles_every?: Maybe<TitleWhereInput>;
  titles_some?: Maybe<TitleWhereInput>;
  titles_none?: Maybe<TitleWhereInput>;
  AND?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
  OR?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
  NOT?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
}

export interface SalaryWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  empNo?: Maybe<EmployeeWhereInput>;
  fromDate?: Maybe<DateTimeInput>;
  fromDate_not?: Maybe<DateTimeInput>;
  fromDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_lt?: Maybe<DateTimeInput>;
  fromDate_lte?: Maybe<DateTimeInput>;
  fromDate_gt?: Maybe<DateTimeInput>;
  fromDate_gte?: Maybe<DateTimeInput>;
  salary?: Maybe<Int>;
  salary_not?: Maybe<Int>;
  salary_in?: Maybe<Int[] | Int>;
  salary_not_in?: Maybe<Int[] | Int>;
  salary_lt?: Maybe<Int>;
  salary_lte?: Maybe<Int>;
  salary_gt?: Maybe<Int>;
  salary_gte?: Maybe<Int>;
  toDate?: Maybe<DateTimeInput>;
  toDate_not?: Maybe<DateTimeInput>;
  toDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_lt?: Maybe<DateTimeInput>;
  toDate_lte?: Maybe<DateTimeInput>;
  toDate_gt?: Maybe<DateTimeInput>;
  toDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SalaryWhereInput[] | SalaryWhereInput>;
  OR?: Maybe<SalaryWhereInput[] | SalaryWhereInput>;
  NOT?: Maybe<SalaryWhereInput[] | SalaryWhereInput>;
}

export interface TitleWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  empNo?: Maybe<EmployeeWhereInput>;
  fromDate?: Maybe<DateTimeInput>;
  fromDate_not?: Maybe<DateTimeInput>;
  fromDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_lt?: Maybe<DateTimeInput>;
  fromDate_lte?: Maybe<DateTimeInput>;
  fromDate_gt?: Maybe<DateTimeInput>;
  fromDate_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  toDate?: Maybe<DateTimeInput>;
  toDate_not?: Maybe<DateTimeInput>;
  toDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_lt?: Maybe<DateTimeInput>;
  toDate_lte?: Maybe<DateTimeInput>;
  toDate_gt?: Maybe<DateTimeInput>;
  toDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TitleWhereInput[] | TitleWhereInput>;
  OR?: Maybe<TitleWhereInput[] | TitleWhereInput>;
  NOT?: Maybe<TitleWhereInput[] | TitleWhereInput>;
}

export type DeptEmpWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type DeptManagerWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type EmployeeWhereUniqueInput = AtLeastOne<{
  emp_no: Maybe<Int>;
}>;

export type SalaryWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type TitleWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DepartmentCreateInput {
  dept_no?: Maybe<ID_Input>;
  deptName: String;
  deptEmp?: Maybe<DeptEmpCreateManyWithoutDeptNoInput>;
  deptManagers?: Maybe<DeptManagerCreateManyWithoutDeptNoInput>;
}

export interface DeptEmpCreateManyWithoutDeptNoInput {
  create?: Maybe<
    DeptEmpCreateWithoutDeptNoInput[] | DeptEmpCreateWithoutDeptNoInput
  >;
  connect?: Maybe<DeptEmpWhereUniqueInput[] | DeptEmpWhereUniqueInput>;
}

export interface DeptEmpCreateWithoutDeptNoInput {
  id?: Maybe<Int>;
  empNo: EmployeeCreateOneWithoutDeptEmpInput;
  fromDate: DateTimeInput;
  toDate: DateTimeInput;
}

export interface EmployeeCreateOneWithoutDeptEmpInput {
  create?: Maybe<EmployeeCreateWithoutDeptEmpInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutDeptEmpInput {
  emp_no?: Maybe<Int>;
  birthDate: DateTimeInput;
  firstName: String;
  gender: EmployeesGenderEnum;
  hireDate: DateTimeInput;
  lastName: String;
  deptManagers?: Maybe<DeptManagerCreateManyWithoutEmpNoInput>;
  salaries?: Maybe<SalaryCreateManyWithoutEmpNoInput>;
  titles?: Maybe<TitleCreateManyWithoutEmpNoInput>;
}

export interface DeptManagerCreateManyWithoutEmpNoInput {
  create?: Maybe<
    DeptManagerCreateWithoutEmpNoInput[] | DeptManagerCreateWithoutEmpNoInput
  >;
  connect?: Maybe<DeptManagerWhereUniqueInput[] | DeptManagerWhereUniqueInput>;
}

export interface DeptManagerCreateWithoutEmpNoInput {
  id?: Maybe<Int>;
  deptNo: DepartmentCreateOneWithoutDeptManagersInput;
  fromDate: DateTimeInput;
  toDate: DateTimeInput;
}

export interface DepartmentCreateOneWithoutDeptManagersInput {
  create?: Maybe<DepartmentCreateWithoutDeptManagersInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentCreateWithoutDeptManagersInput {
  dept_no?: Maybe<ID_Input>;
  deptName: String;
  deptEmp?: Maybe<DeptEmpCreateManyWithoutDeptNoInput>;
}

export interface SalaryCreateManyWithoutEmpNoInput {
  create?: Maybe<
    SalaryCreateWithoutEmpNoInput[] | SalaryCreateWithoutEmpNoInput
  >;
  connect?: Maybe<SalaryWhereUniqueInput[] | SalaryWhereUniqueInput>;
}

export interface SalaryCreateWithoutEmpNoInput {
  id?: Maybe<Int>;
  fromDate: DateTimeInput;
  salary: Int;
  toDate: DateTimeInput;
}

export interface TitleCreateManyWithoutEmpNoInput {
  create?: Maybe<TitleCreateWithoutEmpNoInput[] | TitleCreateWithoutEmpNoInput>;
  connect?: Maybe<TitleWhereUniqueInput[] | TitleWhereUniqueInput>;
}

export interface TitleCreateWithoutEmpNoInput {
  id?: Maybe<Int>;
  fromDate: DateTimeInput;
  title: String;
  toDate?: Maybe<DateTimeInput>;
}

export interface DeptManagerCreateManyWithoutDeptNoInput {
  create?: Maybe<
    DeptManagerCreateWithoutDeptNoInput[] | DeptManagerCreateWithoutDeptNoInput
  >;
  connect?: Maybe<DeptManagerWhereUniqueInput[] | DeptManagerWhereUniqueInput>;
}

export interface DeptManagerCreateWithoutDeptNoInput {
  id?: Maybe<Int>;
  empNo: EmployeeCreateOneWithoutDeptManagersInput;
  fromDate: DateTimeInput;
  toDate: DateTimeInput;
}

export interface EmployeeCreateOneWithoutDeptManagersInput {
  create?: Maybe<EmployeeCreateWithoutDeptManagersInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutDeptManagersInput {
  emp_no?: Maybe<Int>;
  birthDate: DateTimeInput;
  firstName: String;
  gender: EmployeesGenderEnum;
  hireDate: DateTimeInput;
  lastName: String;
  deptEmp?: Maybe<DeptEmpCreateManyWithoutEmpNoInput>;
  salaries?: Maybe<SalaryCreateManyWithoutEmpNoInput>;
  titles?: Maybe<TitleCreateManyWithoutEmpNoInput>;
}

export interface DeptEmpCreateManyWithoutEmpNoInput {
  create?: Maybe<
    DeptEmpCreateWithoutEmpNoInput[] | DeptEmpCreateWithoutEmpNoInput
  >;
  connect?: Maybe<DeptEmpWhereUniqueInput[] | DeptEmpWhereUniqueInput>;
}

export interface DeptEmpCreateWithoutEmpNoInput {
  id?: Maybe<Int>;
  deptNo: DepartmentCreateOneWithoutDeptEmpInput;
  fromDate: DateTimeInput;
  toDate: DateTimeInput;
}

export interface DepartmentCreateOneWithoutDeptEmpInput {
  create?: Maybe<DepartmentCreateWithoutDeptEmpInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentCreateWithoutDeptEmpInput {
  dept_no?: Maybe<ID_Input>;
  deptName: String;
  deptManagers?: Maybe<DeptManagerCreateManyWithoutDeptNoInput>;
}

export interface DepartmentUpdateInput {
  deptName?: Maybe<String>;
  deptEmp?: Maybe<DeptEmpUpdateManyWithoutDeptNoInput>;
  deptManagers?: Maybe<DeptManagerUpdateManyWithoutDeptNoInput>;
}

export interface DeptEmpUpdateManyWithoutDeptNoInput {
  create?: Maybe<
    DeptEmpCreateWithoutDeptNoInput[] | DeptEmpCreateWithoutDeptNoInput
  >;
  delete?: Maybe<DeptEmpWhereUniqueInput[] | DeptEmpWhereUniqueInput>;
  connect?: Maybe<DeptEmpWhereUniqueInput[] | DeptEmpWhereUniqueInput>;
  set?: Maybe<DeptEmpWhereUniqueInput[] | DeptEmpWhereUniqueInput>;
  disconnect?: Maybe<DeptEmpWhereUniqueInput[] | DeptEmpWhereUniqueInput>;
  update?: Maybe<
    | DeptEmpUpdateWithWhereUniqueWithoutDeptNoInput[]
    | DeptEmpUpdateWithWhereUniqueWithoutDeptNoInput
  >;
  upsert?: Maybe<
    | DeptEmpUpsertWithWhereUniqueWithoutDeptNoInput[]
    | DeptEmpUpsertWithWhereUniqueWithoutDeptNoInput
  >;
  deleteMany?: Maybe<DeptEmpScalarWhereInput[] | DeptEmpScalarWhereInput>;
  updateMany?: Maybe<
    | DeptEmpUpdateManyWithWhereNestedInput[]
    | DeptEmpUpdateManyWithWhereNestedInput
  >;
}

export interface DeptEmpUpdateWithWhereUniqueWithoutDeptNoInput {
  where: DeptEmpWhereUniqueInput;
  data: DeptEmpUpdateWithoutDeptNoDataInput;
}

export interface DeptEmpUpdateWithoutDeptNoDataInput {
  empNo?: Maybe<EmployeeUpdateOneRequiredWithoutDeptEmpInput>;
  fromDate?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
}

export interface EmployeeUpdateOneRequiredWithoutDeptEmpInput {
  create?: Maybe<EmployeeCreateWithoutDeptEmpInput>;
  update?: Maybe<EmployeeUpdateWithoutDeptEmpDataInput>;
  upsert?: Maybe<EmployeeUpsertWithoutDeptEmpInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeUpdateWithoutDeptEmpDataInput {
  birthDate?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  gender?: Maybe<EmployeesGenderEnum>;
  hireDate?: Maybe<DateTimeInput>;
  lastName?: Maybe<String>;
  deptManagers?: Maybe<DeptManagerUpdateManyWithoutEmpNoInput>;
  salaries?: Maybe<SalaryUpdateManyWithoutEmpNoInput>;
  titles?: Maybe<TitleUpdateManyWithoutEmpNoInput>;
}

export interface DeptManagerUpdateManyWithoutEmpNoInput {
  create?: Maybe<
    DeptManagerCreateWithoutEmpNoInput[] | DeptManagerCreateWithoutEmpNoInput
  >;
  delete?: Maybe<DeptManagerWhereUniqueInput[] | DeptManagerWhereUniqueInput>;
  connect?: Maybe<DeptManagerWhereUniqueInput[] | DeptManagerWhereUniqueInput>;
  set?: Maybe<DeptManagerWhereUniqueInput[] | DeptManagerWhereUniqueInput>;
  disconnect?: Maybe<
    DeptManagerWhereUniqueInput[] | DeptManagerWhereUniqueInput
  >;
  update?: Maybe<
    | DeptManagerUpdateWithWhereUniqueWithoutEmpNoInput[]
    | DeptManagerUpdateWithWhereUniqueWithoutEmpNoInput
  >;
  upsert?: Maybe<
    | DeptManagerUpsertWithWhereUniqueWithoutEmpNoInput[]
    | DeptManagerUpsertWithWhereUniqueWithoutEmpNoInput
  >;
  deleteMany?: Maybe<
    DeptManagerScalarWhereInput[] | DeptManagerScalarWhereInput
  >;
  updateMany?: Maybe<
    | DeptManagerUpdateManyWithWhereNestedInput[]
    | DeptManagerUpdateManyWithWhereNestedInput
  >;
}

export interface DeptManagerUpdateWithWhereUniqueWithoutEmpNoInput {
  where: DeptManagerWhereUniqueInput;
  data: DeptManagerUpdateWithoutEmpNoDataInput;
}

export interface DeptManagerUpdateWithoutEmpNoDataInput {
  deptNo?: Maybe<DepartmentUpdateOneRequiredWithoutDeptManagersInput>;
  fromDate?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
}

export interface DepartmentUpdateOneRequiredWithoutDeptManagersInput {
  create?: Maybe<DepartmentCreateWithoutDeptManagersInput>;
  update?: Maybe<DepartmentUpdateWithoutDeptManagersDataInput>;
  upsert?: Maybe<DepartmentUpsertWithoutDeptManagersInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentUpdateWithoutDeptManagersDataInput {
  deptName?: Maybe<String>;
  deptEmp?: Maybe<DeptEmpUpdateManyWithoutDeptNoInput>;
}

export interface DepartmentUpsertWithoutDeptManagersInput {
  update: DepartmentUpdateWithoutDeptManagersDataInput;
  create: DepartmentCreateWithoutDeptManagersInput;
}

export interface DeptManagerUpsertWithWhereUniqueWithoutEmpNoInput {
  where: DeptManagerWhereUniqueInput;
  update: DeptManagerUpdateWithoutEmpNoDataInput;
  create: DeptManagerCreateWithoutEmpNoInput;
}

export interface DeptManagerScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  fromDate?: Maybe<DateTimeInput>;
  fromDate_not?: Maybe<DateTimeInput>;
  fromDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_lt?: Maybe<DateTimeInput>;
  fromDate_lte?: Maybe<DateTimeInput>;
  fromDate_gt?: Maybe<DateTimeInput>;
  fromDate_gte?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
  toDate_not?: Maybe<DateTimeInput>;
  toDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_lt?: Maybe<DateTimeInput>;
  toDate_lte?: Maybe<DateTimeInput>;
  toDate_gt?: Maybe<DateTimeInput>;
  toDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DeptManagerScalarWhereInput[] | DeptManagerScalarWhereInput>;
  OR?: Maybe<DeptManagerScalarWhereInput[] | DeptManagerScalarWhereInput>;
  NOT?: Maybe<DeptManagerScalarWhereInput[] | DeptManagerScalarWhereInput>;
}

export interface DeptManagerUpdateManyWithWhereNestedInput {
  where: DeptManagerScalarWhereInput;
  data: DeptManagerUpdateManyDataInput;
}

export interface DeptManagerUpdateManyDataInput {
  fromDate?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
}

export interface SalaryUpdateManyWithoutEmpNoInput {
  create?: Maybe<
    SalaryCreateWithoutEmpNoInput[] | SalaryCreateWithoutEmpNoInput
  >;
  delete?: Maybe<SalaryWhereUniqueInput[] | SalaryWhereUniqueInput>;
  connect?: Maybe<SalaryWhereUniqueInput[] | SalaryWhereUniqueInput>;
  set?: Maybe<SalaryWhereUniqueInput[] | SalaryWhereUniqueInput>;
  disconnect?: Maybe<SalaryWhereUniqueInput[] | SalaryWhereUniqueInput>;
  update?: Maybe<
    | SalaryUpdateWithWhereUniqueWithoutEmpNoInput[]
    | SalaryUpdateWithWhereUniqueWithoutEmpNoInput
  >;
  upsert?: Maybe<
    | SalaryUpsertWithWhereUniqueWithoutEmpNoInput[]
    | SalaryUpsertWithWhereUniqueWithoutEmpNoInput
  >;
  deleteMany?: Maybe<SalaryScalarWhereInput[] | SalaryScalarWhereInput>;
  updateMany?: Maybe<
    | SalaryUpdateManyWithWhereNestedInput[]
    | SalaryUpdateManyWithWhereNestedInput
  >;
}

export interface SalaryUpdateWithWhereUniqueWithoutEmpNoInput {
  where: SalaryWhereUniqueInput;
  data: SalaryUpdateWithoutEmpNoDataInput;
}

export interface SalaryUpdateWithoutEmpNoDataInput {
  fromDate?: Maybe<DateTimeInput>;
  salary?: Maybe<Int>;
  toDate?: Maybe<DateTimeInput>;
}

export interface SalaryUpsertWithWhereUniqueWithoutEmpNoInput {
  where: SalaryWhereUniqueInput;
  update: SalaryUpdateWithoutEmpNoDataInput;
  create: SalaryCreateWithoutEmpNoInput;
}

export interface SalaryScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  fromDate?: Maybe<DateTimeInput>;
  fromDate_not?: Maybe<DateTimeInput>;
  fromDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_lt?: Maybe<DateTimeInput>;
  fromDate_lte?: Maybe<DateTimeInput>;
  fromDate_gt?: Maybe<DateTimeInput>;
  fromDate_gte?: Maybe<DateTimeInput>;
  salary?: Maybe<Int>;
  salary_not?: Maybe<Int>;
  salary_in?: Maybe<Int[] | Int>;
  salary_not_in?: Maybe<Int[] | Int>;
  salary_lt?: Maybe<Int>;
  salary_lte?: Maybe<Int>;
  salary_gt?: Maybe<Int>;
  salary_gte?: Maybe<Int>;
  toDate?: Maybe<DateTimeInput>;
  toDate_not?: Maybe<DateTimeInput>;
  toDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_lt?: Maybe<DateTimeInput>;
  toDate_lte?: Maybe<DateTimeInput>;
  toDate_gt?: Maybe<DateTimeInput>;
  toDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SalaryScalarWhereInput[] | SalaryScalarWhereInput>;
  OR?: Maybe<SalaryScalarWhereInput[] | SalaryScalarWhereInput>;
  NOT?: Maybe<SalaryScalarWhereInput[] | SalaryScalarWhereInput>;
}

export interface SalaryUpdateManyWithWhereNestedInput {
  where: SalaryScalarWhereInput;
  data: SalaryUpdateManyDataInput;
}

export interface SalaryUpdateManyDataInput {
  fromDate?: Maybe<DateTimeInput>;
  salary?: Maybe<Int>;
  toDate?: Maybe<DateTimeInput>;
}

export interface TitleUpdateManyWithoutEmpNoInput {
  create?: Maybe<TitleCreateWithoutEmpNoInput[] | TitleCreateWithoutEmpNoInput>;
  delete?: Maybe<TitleWhereUniqueInput[] | TitleWhereUniqueInput>;
  connect?: Maybe<TitleWhereUniqueInput[] | TitleWhereUniqueInput>;
  set?: Maybe<TitleWhereUniqueInput[] | TitleWhereUniqueInput>;
  disconnect?: Maybe<TitleWhereUniqueInput[] | TitleWhereUniqueInput>;
  update?: Maybe<
    | TitleUpdateWithWhereUniqueWithoutEmpNoInput[]
    | TitleUpdateWithWhereUniqueWithoutEmpNoInput
  >;
  upsert?: Maybe<
    | TitleUpsertWithWhereUniqueWithoutEmpNoInput[]
    | TitleUpsertWithWhereUniqueWithoutEmpNoInput
  >;
  deleteMany?: Maybe<TitleScalarWhereInput[] | TitleScalarWhereInput>;
  updateMany?: Maybe<
    TitleUpdateManyWithWhereNestedInput[] | TitleUpdateManyWithWhereNestedInput
  >;
}

export interface TitleUpdateWithWhereUniqueWithoutEmpNoInput {
  where: TitleWhereUniqueInput;
  data: TitleUpdateWithoutEmpNoDataInput;
}

export interface TitleUpdateWithoutEmpNoDataInput {
  fromDate?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  toDate?: Maybe<DateTimeInput>;
}

export interface TitleUpsertWithWhereUniqueWithoutEmpNoInput {
  where: TitleWhereUniqueInput;
  update: TitleUpdateWithoutEmpNoDataInput;
  create: TitleCreateWithoutEmpNoInput;
}

export interface TitleScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  fromDate?: Maybe<DateTimeInput>;
  fromDate_not?: Maybe<DateTimeInput>;
  fromDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_lt?: Maybe<DateTimeInput>;
  fromDate_lte?: Maybe<DateTimeInput>;
  fromDate_gt?: Maybe<DateTimeInput>;
  fromDate_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  toDate?: Maybe<DateTimeInput>;
  toDate_not?: Maybe<DateTimeInput>;
  toDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_lt?: Maybe<DateTimeInput>;
  toDate_lte?: Maybe<DateTimeInput>;
  toDate_gt?: Maybe<DateTimeInput>;
  toDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TitleScalarWhereInput[] | TitleScalarWhereInput>;
  OR?: Maybe<TitleScalarWhereInput[] | TitleScalarWhereInput>;
  NOT?: Maybe<TitleScalarWhereInput[] | TitleScalarWhereInput>;
}

export interface TitleUpdateManyWithWhereNestedInput {
  where: TitleScalarWhereInput;
  data: TitleUpdateManyDataInput;
}

export interface TitleUpdateManyDataInput {
  fromDate?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  toDate?: Maybe<DateTimeInput>;
}

export interface EmployeeUpsertWithoutDeptEmpInput {
  update: EmployeeUpdateWithoutDeptEmpDataInput;
  create: EmployeeCreateWithoutDeptEmpInput;
}

export interface DeptEmpUpsertWithWhereUniqueWithoutDeptNoInput {
  where: DeptEmpWhereUniqueInput;
  update: DeptEmpUpdateWithoutDeptNoDataInput;
  create: DeptEmpCreateWithoutDeptNoInput;
}

export interface DeptEmpScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  fromDate?: Maybe<DateTimeInput>;
  fromDate_not?: Maybe<DateTimeInput>;
  fromDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  fromDate_lt?: Maybe<DateTimeInput>;
  fromDate_lte?: Maybe<DateTimeInput>;
  fromDate_gt?: Maybe<DateTimeInput>;
  fromDate_gte?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
  toDate_not?: Maybe<DateTimeInput>;
  toDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  toDate_lt?: Maybe<DateTimeInput>;
  toDate_lte?: Maybe<DateTimeInput>;
  toDate_gt?: Maybe<DateTimeInput>;
  toDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DeptEmpScalarWhereInput[] | DeptEmpScalarWhereInput>;
  OR?: Maybe<DeptEmpScalarWhereInput[] | DeptEmpScalarWhereInput>;
  NOT?: Maybe<DeptEmpScalarWhereInput[] | DeptEmpScalarWhereInput>;
}

export interface DeptEmpUpdateManyWithWhereNestedInput {
  where: DeptEmpScalarWhereInput;
  data: DeptEmpUpdateManyDataInput;
}

export interface DeptEmpUpdateManyDataInput {
  fromDate?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
}

export interface DeptManagerUpdateManyWithoutDeptNoInput {
  create?: Maybe<
    DeptManagerCreateWithoutDeptNoInput[] | DeptManagerCreateWithoutDeptNoInput
  >;
  delete?: Maybe<DeptManagerWhereUniqueInput[] | DeptManagerWhereUniqueInput>;
  connect?: Maybe<DeptManagerWhereUniqueInput[] | DeptManagerWhereUniqueInput>;
  set?: Maybe<DeptManagerWhereUniqueInput[] | DeptManagerWhereUniqueInput>;
  disconnect?: Maybe<
    DeptManagerWhereUniqueInput[] | DeptManagerWhereUniqueInput
  >;
  update?: Maybe<
    | DeptManagerUpdateWithWhereUniqueWithoutDeptNoInput[]
    | DeptManagerUpdateWithWhereUniqueWithoutDeptNoInput
  >;
  upsert?: Maybe<
    | DeptManagerUpsertWithWhereUniqueWithoutDeptNoInput[]
    | DeptManagerUpsertWithWhereUniqueWithoutDeptNoInput
  >;
  deleteMany?: Maybe<
    DeptManagerScalarWhereInput[] | DeptManagerScalarWhereInput
  >;
  updateMany?: Maybe<
    | DeptManagerUpdateManyWithWhereNestedInput[]
    | DeptManagerUpdateManyWithWhereNestedInput
  >;
}

export interface DeptManagerUpdateWithWhereUniqueWithoutDeptNoInput {
  where: DeptManagerWhereUniqueInput;
  data: DeptManagerUpdateWithoutDeptNoDataInput;
}

export interface DeptManagerUpdateWithoutDeptNoDataInput {
  empNo?: Maybe<EmployeeUpdateOneRequiredWithoutDeptManagersInput>;
  fromDate?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
}

export interface EmployeeUpdateOneRequiredWithoutDeptManagersInput {
  create?: Maybe<EmployeeCreateWithoutDeptManagersInput>;
  update?: Maybe<EmployeeUpdateWithoutDeptManagersDataInput>;
  upsert?: Maybe<EmployeeUpsertWithoutDeptManagersInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeUpdateWithoutDeptManagersDataInput {
  birthDate?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  gender?: Maybe<EmployeesGenderEnum>;
  hireDate?: Maybe<DateTimeInput>;
  lastName?: Maybe<String>;
  deptEmp?: Maybe<DeptEmpUpdateManyWithoutEmpNoInput>;
  salaries?: Maybe<SalaryUpdateManyWithoutEmpNoInput>;
  titles?: Maybe<TitleUpdateManyWithoutEmpNoInput>;
}

export interface DeptEmpUpdateManyWithoutEmpNoInput {
  create?: Maybe<
    DeptEmpCreateWithoutEmpNoInput[] | DeptEmpCreateWithoutEmpNoInput
  >;
  delete?: Maybe<DeptEmpWhereUniqueInput[] | DeptEmpWhereUniqueInput>;
  connect?: Maybe<DeptEmpWhereUniqueInput[] | DeptEmpWhereUniqueInput>;
  set?: Maybe<DeptEmpWhereUniqueInput[] | DeptEmpWhereUniqueInput>;
  disconnect?: Maybe<DeptEmpWhereUniqueInput[] | DeptEmpWhereUniqueInput>;
  update?: Maybe<
    | DeptEmpUpdateWithWhereUniqueWithoutEmpNoInput[]
    | DeptEmpUpdateWithWhereUniqueWithoutEmpNoInput
  >;
  upsert?: Maybe<
    | DeptEmpUpsertWithWhereUniqueWithoutEmpNoInput[]
    | DeptEmpUpsertWithWhereUniqueWithoutEmpNoInput
  >;
  deleteMany?: Maybe<DeptEmpScalarWhereInput[] | DeptEmpScalarWhereInput>;
  updateMany?: Maybe<
    | DeptEmpUpdateManyWithWhereNestedInput[]
    | DeptEmpUpdateManyWithWhereNestedInput
  >;
}

export interface DeptEmpUpdateWithWhereUniqueWithoutEmpNoInput {
  where: DeptEmpWhereUniqueInput;
  data: DeptEmpUpdateWithoutEmpNoDataInput;
}

export interface DeptEmpUpdateWithoutEmpNoDataInput {
  deptNo?: Maybe<DepartmentUpdateOneRequiredWithoutDeptEmpInput>;
  fromDate?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
}

export interface DepartmentUpdateOneRequiredWithoutDeptEmpInput {
  create?: Maybe<DepartmentCreateWithoutDeptEmpInput>;
  update?: Maybe<DepartmentUpdateWithoutDeptEmpDataInput>;
  upsert?: Maybe<DepartmentUpsertWithoutDeptEmpInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentUpdateWithoutDeptEmpDataInput {
  deptName?: Maybe<String>;
  deptManagers?: Maybe<DeptManagerUpdateManyWithoutDeptNoInput>;
}

export interface DepartmentUpsertWithoutDeptEmpInput {
  update: DepartmentUpdateWithoutDeptEmpDataInput;
  create: DepartmentCreateWithoutDeptEmpInput;
}

export interface DeptEmpUpsertWithWhereUniqueWithoutEmpNoInput {
  where: DeptEmpWhereUniqueInput;
  update: DeptEmpUpdateWithoutEmpNoDataInput;
  create: DeptEmpCreateWithoutEmpNoInput;
}

export interface EmployeeUpsertWithoutDeptManagersInput {
  update: EmployeeUpdateWithoutDeptManagersDataInput;
  create: EmployeeCreateWithoutDeptManagersInput;
}

export interface DeptManagerUpsertWithWhereUniqueWithoutDeptNoInput {
  where: DeptManagerWhereUniqueInput;
  update: DeptManagerUpdateWithoutDeptNoDataInput;
  create: DeptManagerCreateWithoutDeptNoInput;
}

export interface DepartmentUpdateManyMutationInput {
  deptName?: Maybe<String>;
}

export interface DeptEmpCreateInput {
  id?: Maybe<Int>;
  deptNo: DepartmentCreateOneWithoutDeptEmpInput;
  empNo: EmployeeCreateOneWithoutDeptEmpInput;
  fromDate: DateTimeInput;
  toDate: DateTimeInput;
}

export interface DeptEmpUpdateInput {
  deptNo?: Maybe<DepartmentUpdateOneRequiredWithoutDeptEmpInput>;
  empNo?: Maybe<EmployeeUpdateOneRequiredWithoutDeptEmpInput>;
  fromDate?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
}

export interface DeptEmpUpdateManyMutationInput {
  fromDate?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
}

export interface DeptManagerCreateInput {
  id?: Maybe<Int>;
  deptNo: DepartmentCreateOneWithoutDeptManagersInput;
  empNo: EmployeeCreateOneWithoutDeptManagersInput;
  fromDate: DateTimeInput;
  toDate: DateTimeInput;
}

export interface DeptManagerUpdateInput {
  deptNo?: Maybe<DepartmentUpdateOneRequiredWithoutDeptManagersInput>;
  empNo?: Maybe<EmployeeUpdateOneRequiredWithoutDeptManagersInput>;
  fromDate?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
}

export interface DeptManagerUpdateManyMutationInput {
  fromDate?: Maybe<DateTimeInput>;
  toDate?: Maybe<DateTimeInput>;
}

export interface EmployeeCreateInput {
  emp_no?: Maybe<Int>;
  birthDate: DateTimeInput;
  firstName: String;
  gender: EmployeesGenderEnum;
  hireDate: DateTimeInput;
  lastName: String;
  deptEmp?: Maybe<DeptEmpCreateManyWithoutEmpNoInput>;
  deptManagers?: Maybe<DeptManagerCreateManyWithoutEmpNoInput>;
  salaries?: Maybe<SalaryCreateManyWithoutEmpNoInput>;
  titles?: Maybe<TitleCreateManyWithoutEmpNoInput>;
}

export interface EmployeeUpdateInput {
  birthDate?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  gender?: Maybe<EmployeesGenderEnum>;
  hireDate?: Maybe<DateTimeInput>;
  lastName?: Maybe<String>;
  deptEmp?: Maybe<DeptEmpUpdateManyWithoutEmpNoInput>;
  deptManagers?: Maybe<DeptManagerUpdateManyWithoutEmpNoInput>;
  salaries?: Maybe<SalaryUpdateManyWithoutEmpNoInput>;
  titles?: Maybe<TitleUpdateManyWithoutEmpNoInput>;
}

export interface EmployeeUpdateManyMutationInput {
  birthDate?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  gender?: Maybe<EmployeesGenderEnum>;
  hireDate?: Maybe<DateTimeInput>;
  lastName?: Maybe<String>;
}

export interface SalaryCreateInput {
  id?: Maybe<Int>;
  empNo: EmployeeCreateOneWithoutSalariesInput;
  fromDate: DateTimeInput;
  salary: Int;
  toDate: DateTimeInput;
}

export interface EmployeeCreateOneWithoutSalariesInput {
  create?: Maybe<EmployeeCreateWithoutSalariesInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutSalariesInput {
  emp_no?: Maybe<Int>;
  birthDate: DateTimeInput;
  firstName: String;
  gender: EmployeesGenderEnum;
  hireDate: DateTimeInput;
  lastName: String;
  deptEmp?: Maybe<DeptEmpCreateManyWithoutEmpNoInput>;
  deptManagers?: Maybe<DeptManagerCreateManyWithoutEmpNoInput>;
  titles?: Maybe<TitleCreateManyWithoutEmpNoInput>;
}

export interface SalaryUpdateInput {
  empNo?: Maybe<EmployeeUpdateOneRequiredWithoutSalariesInput>;
  fromDate?: Maybe<DateTimeInput>;
  salary?: Maybe<Int>;
  toDate?: Maybe<DateTimeInput>;
}

export interface EmployeeUpdateOneRequiredWithoutSalariesInput {
  create?: Maybe<EmployeeCreateWithoutSalariesInput>;
  update?: Maybe<EmployeeUpdateWithoutSalariesDataInput>;
  upsert?: Maybe<EmployeeUpsertWithoutSalariesInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeUpdateWithoutSalariesDataInput {
  birthDate?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  gender?: Maybe<EmployeesGenderEnum>;
  hireDate?: Maybe<DateTimeInput>;
  lastName?: Maybe<String>;
  deptEmp?: Maybe<DeptEmpUpdateManyWithoutEmpNoInput>;
  deptManagers?: Maybe<DeptManagerUpdateManyWithoutEmpNoInput>;
  titles?: Maybe<TitleUpdateManyWithoutEmpNoInput>;
}

export interface EmployeeUpsertWithoutSalariesInput {
  update: EmployeeUpdateWithoutSalariesDataInput;
  create: EmployeeCreateWithoutSalariesInput;
}

export interface SalaryUpdateManyMutationInput {
  fromDate?: Maybe<DateTimeInput>;
  salary?: Maybe<Int>;
  toDate?: Maybe<DateTimeInput>;
}

export interface TitleCreateInput {
  id?: Maybe<Int>;
  empNo: EmployeeCreateOneWithoutTitlesInput;
  fromDate: DateTimeInput;
  title: String;
  toDate?: Maybe<DateTimeInput>;
}

export interface EmployeeCreateOneWithoutTitlesInput {
  create?: Maybe<EmployeeCreateWithoutTitlesInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutTitlesInput {
  emp_no?: Maybe<Int>;
  birthDate: DateTimeInput;
  firstName: String;
  gender: EmployeesGenderEnum;
  hireDate: DateTimeInput;
  lastName: String;
  deptEmp?: Maybe<DeptEmpCreateManyWithoutEmpNoInput>;
  deptManagers?: Maybe<DeptManagerCreateManyWithoutEmpNoInput>;
  salaries?: Maybe<SalaryCreateManyWithoutEmpNoInput>;
}

export interface TitleUpdateInput {
  empNo?: Maybe<EmployeeUpdateOneRequiredWithoutTitlesInput>;
  fromDate?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  toDate?: Maybe<DateTimeInput>;
}

export interface EmployeeUpdateOneRequiredWithoutTitlesInput {
  create?: Maybe<EmployeeCreateWithoutTitlesInput>;
  update?: Maybe<EmployeeUpdateWithoutTitlesDataInput>;
  upsert?: Maybe<EmployeeUpsertWithoutTitlesInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeUpdateWithoutTitlesDataInput {
  birthDate?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  gender?: Maybe<EmployeesGenderEnum>;
  hireDate?: Maybe<DateTimeInput>;
  lastName?: Maybe<String>;
  deptEmp?: Maybe<DeptEmpUpdateManyWithoutEmpNoInput>;
  deptManagers?: Maybe<DeptManagerUpdateManyWithoutEmpNoInput>;
  salaries?: Maybe<SalaryUpdateManyWithoutEmpNoInput>;
}

export interface EmployeeUpsertWithoutTitlesInput {
  update: EmployeeUpdateWithoutTitlesDataInput;
  create: EmployeeCreateWithoutTitlesInput;
}

export interface TitleUpdateManyMutationInput {
  fromDate?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  toDate?: Maybe<DateTimeInput>;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DepartmentWhereInput>;
  AND?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
}

export interface DeptEmpSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DeptEmpWhereInput>;
  AND?: Maybe<DeptEmpSubscriptionWhereInput[] | DeptEmpSubscriptionWhereInput>;
  OR?: Maybe<DeptEmpSubscriptionWhereInput[] | DeptEmpSubscriptionWhereInput>;
  NOT?: Maybe<DeptEmpSubscriptionWhereInput[] | DeptEmpSubscriptionWhereInput>;
}

export interface DeptManagerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DeptManagerWhereInput>;
  AND?: Maybe<
    DeptManagerSubscriptionWhereInput[] | DeptManagerSubscriptionWhereInput
  >;
  OR?: Maybe<
    DeptManagerSubscriptionWhereInput[] | DeptManagerSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DeptManagerSubscriptionWhereInput[] | DeptManagerSubscriptionWhereInput
  >;
}

export interface EmployeeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmployeeWhereInput>;
  AND?: Maybe<
    EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput
  >;
  OR?: Maybe<EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput>;
  NOT?: Maybe<
    EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput
  >;
}

export interface SalarySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SalaryWhereInput>;
  AND?: Maybe<SalarySubscriptionWhereInput[] | SalarySubscriptionWhereInput>;
  OR?: Maybe<SalarySubscriptionWhereInput[] | SalarySubscriptionWhereInput>;
  NOT?: Maybe<SalarySubscriptionWhereInput[] | SalarySubscriptionWhereInput>;
}

export interface TitleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TitleWhereInput>;
  AND?: Maybe<TitleSubscriptionWhereInput[] | TitleSubscriptionWhereInput>;
  OR?: Maybe<TitleSubscriptionWhereInput[] | TitleSubscriptionWhereInput>;
  NOT?: Maybe<TitleSubscriptionWhereInput[] | TitleSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Department {
  dept_no: ID_Output;
  deptName: String;
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
  dept_no: () => Promise<ID_Output>;
  deptName: () => Promise<String>;
  deptEmp: <T = FragmentableArray<DeptEmp>>(args?: {
    where?: DeptEmpWhereInput;
    orderBy?: DeptEmpOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deptManagers: <T = FragmentableArray<DeptManager>>(args?: {
    where?: DeptManagerWhereInput;
    orderBy?: DeptManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentSubscription
  extends Promise<AsyncIterator<Department>>,
    Fragmentable {
  dept_no: () => Promise<AsyncIterator<ID_Output>>;
  deptName: () => Promise<AsyncIterator<String>>;
  deptEmp: <T = Promise<AsyncIterator<DeptEmpSubscription>>>(args?: {
    where?: DeptEmpWhereInput;
    orderBy?: DeptEmpOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deptManagers: <T = Promise<AsyncIterator<DeptManagerSubscription>>>(args?: {
    where?: DeptManagerWhereInput;
    orderBy?: DeptManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentNullablePromise
  extends Promise<Department | null>,
    Fragmentable {
  dept_no: () => Promise<ID_Output>;
  deptName: () => Promise<String>;
  deptEmp: <T = FragmentableArray<DeptEmp>>(args?: {
    where?: DeptEmpWhereInput;
    orderBy?: DeptEmpOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deptManagers: <T = FragmentableArray<DeptManager>>(args?: {
    where?: DeptManagerWhereInput;
    orderBy?: DeptManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DeptEmp {
  id: Int;
  fromDate: DateTimeOutput;
  toDate: DateTimeOutput;
}

export interface DeptEmpPromise extends Promise<DeptEmp>, Fragmentable {
  id: () => Promise<Int>;
  deptNo: <T = DepartmentPromise>() => T;
  empNo: <T = EmployeePromise>() => T;
  fromDate: () => Promise<DateTimeOutput>;
  toDate: () => Promise<DateTimeOutput>;
}

export interface DeptEmpSubscription
  extends Promise<AsyncIterator<DeptEmp>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  deptNo: <T = DepartmentSubscription>() => T;
  empNo: <T = EmployeeSubscription>() => T;
  fromDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  toDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DeptEmpNullablePromise
  extends Promise<DeptEmp | null>,
    Fragmentable {
  id: () => Promise<Int>;
  deptNo: <T = DepartmentPromise>() => T;
  empNo: <T = EmployeePromise>() => T;
  fromDate: () => Promise<DateTimeOutput>;
  toDate: () => Promise<DateTimeOutput>;
}

export interface Employee {
  emp_no: Int;
  birthDate: DateTimeOutput;
  firstName: String;
  gender: EmployeesGenderEnum;
  hireDate: DateTimeOutput;
  lastName: String;
}

export interface EmployeePromise extends Promise<Employee>, Fragmentable {
  emp_no: () => Promise<Int>;
  birthDate: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  gender: () => Promise<EmployeesGenderEnum>;
  hireDate: () => Promise<DateTimeOutput>;
  lastName: () => Promise<String>;
  deptEmp: <T = FragmentableArray<DeptEmp>>(args?: {
    where?: DeptEmpWhereInput;
    orderBy?: DeptEmpOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deptManagers: <T = FragmentableArray<DeptManager>>(args?: {
    where?: DeptManagerWhereInput;
    orderBy?: DeptManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  salaries: <T = FragmentableArray<Salary>>(args?: {
    where?: SalaryWhereInput;
    orderBy?: SalaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  titles: <T = FragmentableArray<Title>>(args?: {
    where?: TitleWhereInput;
    orderBy?: TitleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EmployeeSubscription
  extends Promise<AsyncIterator<Employee>>,
    Fragmentable {
  emp_no: () => Promise<AsyncIterator<Int>>;
  birthDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<EmployeesGenderEnum>>;
  hireDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastName: () => Promise<AsyncIterator<String>>;
  deptEmp: <T = Promise<AsyncIterator<DeptEmpSubscription>>>(args?: {
    where?: DeptEmpWhereInput;
    orderBy?: DeptEmpOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deptManagers: <T = Promise<AsyncIterator<DeptManagerSubscription>>>(args?: {
    where?: DeptManagerWhereInput;
    orderBy?: DeptManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  salaries: <T = Promise<AsyncIterator<SalarySubscription>>>(args?: {
    where?: SalaryWhereInput;
    orderBy?: SalaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  titles: <T = Promise<AsyncIterator<TitleSubscription>>>(args?: {
    where?: TitleWhereInput;
    orderBy?: TitleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EmployeeNullablePromise
  extends Promise<Employee | null>,
    Fragmentable {
  emp_no: () => Promise<Int>;
  birthDate: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  gender: () => Promise<EmployeesGenderEnum>;
  hireDate: () => Promise<DateTimeOutput>;
  lastName: () => Promise<String>;
  deptEmp: <T = FragmentableArray<DeptEmp>>(args?: {
    where?: DeptEmpWhereInput;
    orderBy?: DeptEmpOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deptManagers: <T = FragmentableArray<DeptManager>>(args?: {
    where?: DeptManagerWhereInput;
    orderBy?: DeptManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  salaries: <T = FragmentableArray<Salary>>(args?: {
    where?: SalaryWhereInput;
    orderBy?: SalaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  titles: <T = FragmentableArray<Title>>(args?: {
    where?: TitleWhereInput;
    orderBy?: TitleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DeptManager {
  id: Int;
  fromDate: DateTimeOutput;
  toDate: DateTimeOutput;
}

export interface DeptManagerPromise extends Promise<DeptManager>, Fragmentable {
  id: () => Promise<Int>;
  deptNo: <T = DepartmentPromise>() => T;
  empNo: <T = EmployeePromise>() => T;
  fromDate: () => Promise<DateTimeOutput>;
  toDate: () => Promise<DateTimeOutput>;
}

export interface DeptManagerSubscription
  extends Promise<AsyncIterator<DeptManager>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  deptNo: <T = DepartmentSubscription>() => T;
  empNo: <T = EmployeeSubscription>() => T;
  fromDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  toDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DeptManagerNullablePromise
  extends Promise<DeptManager | null>,
    Fragmentable {
  id: () => Promise<Int>;
  deptNo: <T = DepartmentPromise>() => T;
  empNo: <T = EmployeePromise>() => T;
  fromDate: () => Promise<DateTimeOutput>;
  toDate: () => Promise<DateTimeOutput>;
}

export interface Salary {
  id: Int;
  fromDate: DateTimeOutput;
  salary: Int;
  toDate: DateTimeOutput;
}

export interface SalaryPromise extends Promise<Salary>, Fragmentable {
  id: () => Promise<Int>;
  empNo: <T = EmployeePromise>() => T;
  fromDate: () => Promise<DateTimeOutput>;
  salary: () => Promise<Int>;
  toDate: () => Promise<DateTimeOutput>;
}

export interface SalarySubscription
  extends Promise<AsyncIterator<Salary>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  empNo: <T = EmployeeSubscription>() => T;
  fromDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  salary: () => Promise<AsyncIterator<Int>>;
  toDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SalaryNullablePromise
  extends Promise<Salary | null>,
    Fragmentable {
  id: () => Promise<Int>;
  empNo: <T = EmployeePromise>() => T;
  fromDate: () => Promise<DateTimeOutput>;
  salary: () => Promise<Int>;
  toDate: () => Promise<DateTimeOutput>;
}

export interface Title {
  id: Int;
  fromDate: DateTimeOutput;
  title: String;
  toDate?: DateTimeOutput;
}

export interface TitlePromise extends Promise<Title>, Fragmentable {
  id: () => Promise<Int>;
  empNo: <T = EmployeePromise>() => T;
  fromDate: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  toDate: () => Promise<DateTimeOutput>;
}

export interface TitleSubscription
  extends Promise<AsyncIterator<Title>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  empNo: <T = EmployeeSubscription>() => T;
  fromDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  toDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TitleNullablePromise
  extends Promise<Title | null>,
    Fragmentable {
  id: () => Promise<Int>;
  empNo: <T = EmployeePromise>() => T;
  fromDate: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  toDate: () => Promise<DateTimeOutput>;
}

export interface DepartmentConnection {
  pageInfo: PageInfo;
  edges: DepartmentEdge[];
}

export interface DepartmentConnectionPromise
  extends Promise<DepartmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DepartmentEdge>>() => T;
  aggregate: <T = AggregateDepartmentPromise>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface DepartmentEdge {
  node: Department;
  cursor: String;
}

export interface DepartmentEdgePromise
  extends Promise<DepartmentEdge>,
    Fragmentable {
  node: <T = DepartmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdge>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDepartment {
  count: Int;
}

export interface AggregateDepartmentPromise
  extends Promise<AggregateDepartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DeptEmpConnection {
  pageInfo: PageInfo;
  edges: DeptEmpEdge[];
}

export interface DeptEmpConnectionPromise
  extends Promise<DeptEmpConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DeptEmpEdge>>() => T;
  aggregate: <T = AggregateDeptEmpPromise>() => T;
}

export interface DeptEmpConnectionSubscription
  extends Promise<AsyncIterator<DeptEmpConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DeptEmpEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDeptEmpSubscription>() => T;
}

export interface DeptEmpEdge {
  node: DeptEmp;
  cursor: String;
}

export interface DeptEmpEdgePromise extends Promise<DeptEmpEdge>, Fragmentable {
  node: <T = DeptEmpPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DeptEmpEdgeSubscription
  extends Promise<AsyncIterator<DeptEmpEdge>>,
    Fragmentable {
  node: <T = DeptEmpSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDeptEmp {
  count: Int;
}

export interface AggregateDeptEmpPromise
  extends Promise<AggregateDeptEmp>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDeptEmpSubscription
  extends Promise<AsyncIterator<AggregateDeptEmp>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DeptManagerConnection {
  pageInfo: PageInfo;
  edges: DeptManagerEdge[];
}

export interface DeptManagerConnectionPromise
  extends Promise<DeptManagerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DeptManagerEdge>>() => T;
  aggregate: <T = AggregateDeptManagerPromise>() => T;
}

export interface DeptManagerConnectionSubscription
  extends Promise<AsyncIterator<DeptManagerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DeptManagerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDeptManagerSubscription>() => T;
}

export interface DeptManagerEdge {
  node: DeptManager;
  cursor: String;
}

export interface DeptManagerEdgePromise
  extends Promise<DeptManagerEdge>,
    Fragmentable {
  node: <T = DeptManagerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DeptManagerEdgeSubscription
  extends Promise<AsyncIterator<DeptManagerEdge>>,
    Fragmentable {
  node: <T = DeptManagerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDeptManager {
  count: Int;
}

export interface AggregateDeptManagerPromise
  extends Promise<AggregateDeptManager>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDeptManagerSubscription
  extends Promise<AsyncIterator<AggregateDeptManager>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeeConnection {
  pageInfo: PageInfo;
  edges: EmployeeEdge[];
}

export interface EmployeeConnectionPromise
  extends Promise<EmployeeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeeEdge>>() => T;
  aggregate: <T = AggregateEmployeePromise>() => T;
}

export interface EmployeeConnectionSubscription
  extends Promise<AsyncIterator<EmployeeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeeSubscription>() => T;
}

export interface EmployeeEdge {
  node: Employee;
  cursor: String;
}

export interface EmployeeEdgePromise
  extends Promise<EmployeeEdge>,
    Fragmentable {
  node: <T = EmployeePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeeEdgeSubscription
  extends Promise<AsyncIterator<EmployeeEdge>>,
    Fragmentable {
  node: <T = EmployeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmployee {
  count: Int;
}

export interface AggregateEmployeePromise
  extends Promise<AggregateEmployee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeeSubscription
  extends Promise<AsyncIterator<AggregateEmployee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SalaryConnection {
  pageInfo: PageInfo;
  edges: SalaryEdge[];
}

export interface SalaryConnectionPromise
  extends Promise<SalaryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SalaryEdge>>() => T;
  aggregate: <T = AggregateSalaryPromise>() => T;
}

export interface SalaryConnectionSubscription
  extends Promise<AsyncIterator<SalaryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SalaryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSalarySubscription>() => T;
}

export interface SalaryEdge {
  node: Salary;
  cursor: String;
}

export interface SalaryEdgePromise extends Promise<SalaryEdge>, Fragmentable {
  node: <T = SalaryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SalaryEdgeSubscription
  extends Promise<AsyncIterator<SalaryEdge>>,
    Fragmentable {
  node: <T = SalarySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSalary {
  count: Int;
}

export interface AggregateSalaryPromise
  extends Promise<AggregateSalary>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSalarySubscription
  extends Promise<AsyncIterator<AggregateSalary>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TitleConnection {
  pageInfo: PageInfo;
  edges: TitleEdge[];
}

export interface TitleConnectionPromise
  extends Promise<TitleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TitleEdge>>() => T;
  aggregate: <T = AggregateTitlePromise>() => T;
}

export interface TitleConnectionSubscription
  extends Promise<AsyncIterator<TitleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TitleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTitleSubscription>() => T;
}

export interface TitleEdge {
  node: Title;
  cursor: String;
}

export interface TitleEdgePromise extends Promise<TitleEdge>, Fragmentable {
  node: <T = TitlePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TitleEdgeSubscription
  extends Promise<AsyncIterator<TitleEdge>>,
    Fragmentable {
  node: <T = TitleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTitle {
  count: Int;
}

export interface AggregateTitlePromise
  extends Promise<AggregateTitle>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTitleSubscription
  extends Promise<AsyncIterator<AggregateTitle>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface DepartmentSubscriptionPayload {
  mutation: MutationType;
  node: Department;
  updatedFields: String[];
  previousValues: DepartmentPreviousValues;
}

export interface DepartmentSubscriptionPayloadPromise
  extends Promise<DepartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DepartmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValuesPromise>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface DepartmentPreviousValues {
  dept_no: ID_Output;
  deptName: String;
}

export interface DepartmentPreviousValuesPromise
  extends Promise<DepartmentPreviousValues>,
    Fragmentable {
  dept_no: () => Promise<ID_Output>;
  deptName: () => Promise<String>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValues>>,
    Fragmentable {
  dept_no: () => Promise<AsyncIterator<ID_Output>>;
  deptName: () => Promise<AsyncIterator<String>>;
}

export interface DeptEmpSubscriptionPayload {
  mutation: MutationType;
  node: DeptEmp;
  updatedFields: String[];
  previousValues: DeptEmpPreviousValues;
}

export interface DeptEmpSubscriptionPayloadPromise
  extends Promise<DeptEmpSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DeptEmpPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DeptEmpPreviousValuesPromise>() => T;
}

export interface DeptEmpSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DeptEmpSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DeptEmpSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DeptEmpPreviousValuesSubscription>() => T;
}

export interface DeptEmpPreviousValues {
  id: Int;
  fromDate: DateTimeOutput;
  toDate: DateTimeOutput;
}

export interface DeptEmpPreviousValuesPromise
  extends Promise<DeptEmpPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  fromDate: () => Promise<DateTimeOutput>;
  toDate: () => Promise<DateTimeOutput>;
}

export interface DeptEmpPreviousValuesSubscription
  extends Promise<AsyncIterator<DeptEmpPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  fromDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  toDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DeptManagerSubscriptionPayload {
  mutation: MutationType;
  node: DeptManager;
  updatedFields: String[];
  previousValues: DeptManagerPreviousValues;
}

export interface DeptManagerSubscriptionPayloadPromise
  extends Promise<DeptManagerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DeptManagerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DeptManagerPreviousValuesPromise>() => T;
}

export interface DeptManagerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DeptManagerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DeptManagerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DeptManagerPreviousValuesSubscription>() => T;
}

export interface DeptManagerPreviousValues {
  id: Int;
  fromDate: DateTimeOutput;
  toDate: DateTimeOutput;
}

export interface DeptManagerPreviousValuesPromise
  extends Promise<DeptManagerPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  fromDate: () => Promise<DateTimeOutput>;
  toDate: () => Promise<DateTimeOutput>;
}

export interface DeptManagerPreviousValuesSubscription
  extends Promise<AsyncIterator<DeptManagerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  fromDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  toDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmployeeSubscriptionPayload {
  mutation: MutationType;
  node: Employee;
  updatedFields: String[];
  previousValues: EmployeePreviousValues;
}

export interface EmployeeSubscriptionPayloadPromise
  extends Promise<EmployeeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployeePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePreviousValuesPromise>() => T;
}

export interface EmployeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeePreviousValuesSubscription>() => T;
}

export interface EmployeePreviousValues {
  emp_no: Int;
  birthDate: DateTimeOutput;
  firstName: String;
  gender: EmployeesGenderEnum;
  hireDate: DateTimeOutput;
  lastName: String;
}

export interface EmployeePreviousValuesPromise
  extends Promise<EmployeePreviousValues>,
    Fragmentable {
  emp_no: () => Promise<Int>;
  birthDate: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  gender: () => Promise<EmployeesGenderEnum>;
  hireDate: () => Promise<DateTimeOutput>;
  lastName: () => Promise<String>;
}

export interface EmployeePreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePreviousValues>>,
    Fragmentable {
  emp_no: () => Promise<AsyncIterator<Int>>;
  birthDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<EmployeesGenderEnum>>;
  hireDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastName: () => Promise<AsyncIterator<String>>;
}

export interface SalarySubscriptionPayload {
  mutation: MutationType;
  node: Salary;
  updatedFields: String[];
  previousValues: SalaryPreviousValues;
}

export interface SalarySubscriptionPayloadPromise
  extends Promise<SalarySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SalaryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SalaryPreviousValuesPromise>() => T;
}

export interface SalarySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SalarySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SalarySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SalaryPreviousValuesSubscription>() => T;
}

export interface SalaryPreviousValues {
  id: Int;
  fromDate: DateTimeOutput;
  salary: Int;
  toDate: DateTimeOutput;
}

export interface SalaryPreviousValuesPromise
  extends Promise<SalaryPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  fromDate: () => Promise<DateTimeOutput>;
  salary: () => Promise<Int>;
  toDate: () => Promise<DateTimeOutput>;
}

export interface SalaryPreviousValuesSubscription
  extends Promise<AsyncIterator<SalaryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  fromDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  salary: () => Promise<AsyncIterator<Int>>;
  toDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TitleSubscriptionPayload {
  mutation: MutationType;
  node: Title;
  updatedFields: String[];
  previousValues: TitlePreviousValues;
}

export interface TitleSubscriptionPayloadPromise
  extends Promise<TitleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TitlePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TitlePreviousValuesPromise>() => T;
}

export interface TitleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TitleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TitleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TitlePreviousValuesSubscription>() => T;
}

export interface TitlePreviousValues {
  id: Int;
  fromDate: DateTimeOutput;
  title: String;
  toDate?: DateTimeOutput;
}

export interface TitlePreviousValuesPromise
  extends Promise<TitlePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  fromDate: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  toDate: () => Promise<DateTimeOutput>;
}

export interface TitlePreviousValuesSubscription
  extends Promise<AsyncIterator<TitlePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  fromDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  toDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Department",
    embedded: false
  },
  {
    name: "DeptEmp",
    embedded: false
  },
  {
    name: "DeptManager",
    embedded: false
  },
  {
    name: "Employee",
    embedded: false
  },
  {
    name: "EmployeesGenderEnum",
    embedded: false
  },
  {
    name: "Salary",
    embedded: false
  },
  {
    name: "Title",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
